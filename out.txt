diff --git a/src/main/java/com/holybuckets/foundation/model/ManagedChunk.java b/src/main/java/com/holybuckets/foundation/model/ManagedChunk.java
index 1e096cb..4eace3d 100644
--- a/src/main/java/com/holybuckets/foundation/model/ManagedChunk.java
+++ b/src/main/java/com/holybuckets/foundation/model/ManagedChunk.java
@@ -7,11 +7,9 @@ import com.holybuckets.foundation.HolyBucketsUtility;
 import com.holybuckets.foundation.LoggerBase;
 import com.holybuckets.foundation.exception.InvalidId;
 import com.holybuckets.foundation.modelInterface.IMangedChunkData;
-import com.holybuckets.foundation.modelInterface.IMangedChunkManager;
-import com.holybuckets.orecluster.core.OreClusterManager;
-import com.holybuckets.orecluster.model.ManagedOreClusterChunk;
 import net.minecraft.core.BlockPos;
 import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.ChunkPos;
 import net.minecraft.world.level.Level;
 import net.minecraft.world.level.LevelAccessor;
 import net.minecraft.world.level.block.Block;
@@ -21,20 +19,20 @@ import net.minecraftforge.event.level.ChunkEvent;
 import org.apache.commons.lang3.tuple.Pair;
 
 import java.util.*;
-import java.util.concurrent.LinkedBlockingQueue;
 
 public class ManagedChunk implements IMangedChunkData {
 
     public static final String CLASS_ID = "003";
-    public static final String NBT_KEY_HEADER = "managedChunk";
+    //public static final String NBT_KEY_HEADER = "managedChunk";
     public static final GeneralRealTimeConfig GENERAL_CONFIG = GeneralRealTimeConfig.getInstance();
     public static final HashMap<Class<? extends IMangedChunkData>, IMangedChunkData> MANAGED_SUBCLASSES = new HashMap<>();
+    public static final HashMap<String, ManagedChunk> LOADED_CHUNKS = new HashMap<>();
     public static final Gson GSON_BUILDER = new GsonBuilder().serializeNulls().create();
 
     private String id;
     private LevelAccessor level;
     private ChunkAccess chunk;
-    private int tickLastLoaded;
+    private int tickWritten;
     private int tickLoaded;
     private final HashMap<Class<? extends IMangedChunkData>, IMangedChunkData> managedChunkData = new HashMap<>();
 
@@ -50,11 +48,14 @@ public class ManagedChunk implements IMangedChunkData {
         this.deserializeNBT(tag);
     }
 
-    public ManagedChunk(LevelAccessor level, String id)
+    public ManagedChunk(LevelAccessor level, String id, ChunkAccess chunk)
     {
         this();
         this.id = id;
         this.level = level;
+        this.tickWritten = GENERAL_CONFIG.getSERVER().getTickCount();
+        this.tickLoaded = GENERAL_CONFIG.getSERVER().getTickCount();
+        this.chunk = chunk;
         //Dont init here, working static maps will never be ready at this time
     }
 
@@ -77,6 +78,13 @@ public class ManagedChunk implements IMangedChunkData {
         return true;
     }
 
+    public void setChunk(LevelAccessor level, String id) {
+        ChunkPos p = HolyBucketsUtility.ChunkUtil.getPos(id);
+        this.chunk = level.getChunk(p.x, p.z);
+    }
+
+
+
     private void initSubclassesFromMemory(LevelAccessor level, String chunkId)
     {
         for(Map.Entry<Class<? extends IMangedChunkData>, IMangedChunkData> data : MANAGED_SUBCLASSES.entrySet() ) {
@@ -91,6 +99,7 @@ public class ManagedChunk implements IMangedChunkData {
     {
         this.id = id;
         this.level = level;
+        this.setChunk(level, id);
         HashMap<String, String> errors = new HashMap<>();
 
         //Attempt to link existing subclasses from RAM
@@ -154,14 +163,16 @@ public class ManagedChunk implements IMangedChunkData {
     public CompoundTag serializeNBT()
     {
         CompoundTag details = new CompoundTag();
-        CompoundTag wrapper = new CompoundTag();
 
-        if( this.id == null || this.level == null )
-            return wrapper;
+        if( this.id == null || this.level == null ) {
+            LoggerBase.logError(null, "003004", "ManagedChunk not initialized with id or level and cannot be serialized");
+            return details;
+        }
+
 
         details.putString("id", this.id);
         details.putInt("level", this.level.hashCode());
-        details.putInt("tickLastLoaded", GENERAL_CONFIG.getSERVER().getTickCount());
+        details.putInt("tickWritten", GENERAL_CONFIG.getSERVER().getTickCount());
 
         this.initSubclassesFromMemory(level, id);
 
@@ -173,35 +184,27 @@ public class ManagedChunk implements IMangedChunkData {
             details.put(data.getClass().getName(), data.serializeNBT());
         }
 
-        if( this.id != null)
-            wrapper.put(NBT_KEY_HEADER, details);
-
-        LoggerBase.logDebug( null,"003002", "Serializing ManagedChunk with data: " + wrapper);
+        LoggerBase.logDebug( null,"003002", "Serializing ManagedChunk with data: " + details);
 
-        return wrapper;
+        return details;
     }
 
     @Override
     public void deserializeNBT(CompoundTag tag)
     {
-        if(tag == null)
+        if(tag == null || tag.isEmpty()) {
             return;
-
-        CompoundTag details = tag.getCompound(NBT_KEY_HEADER);
-
-        if(true)
-        {
-            //return;
         }
 
+
         //print tag as string, info
-        this.id = details.getString("id");
+        this.id = tag.getString("id");
         this.level = GENERAL_CONFIG.getLEVELS().get( tag.get("level") );
-        this.tickLastLoaded = details.getInt("tickLastLoaded");
+        this.tickWritten = tag.getInt("tickWritten");
         this.tickLoaded = GENERAL_CONFIG.getSERVER().getTickCount();
 
         try {
-            this.init(level, id, details );
+            this.init(level, id, tag );
         } catch (InvalidId e) {
             LoggerBase.logError(null, "002021", "Error initializing ManagedChunk with id: " + id);
         }
@@ -225,6 +228,7 @@ public class ManagedChunk implements IMangedChunkData {
         }
         else
         {
+            LOADED_CHUNKS.put(chunkId, new ManagedChunk(level, chunkId, chunk));
             levelChunk.getCapability(ManagedChunkCapabilityProvider.MANAGED_CHUNK).ifPresent(c -> {
                     c.initSubclassesFromMemory(level, chunkId);
             });
@@ -299,7 +303,7 @@ public class ManagedChunk implements IMangedChunkData {
         {
             //Release all locks
             for(LevelChunkSection s : chunk.getSections()) {
-                s.release();
+                //s.release();
             }
         }
 
